package gov.nasa.jpf.units.preprocessor;

import gov.nasa.jpf.units.UnitIdentifierType;
import gov.nasa.jpf.units.preprocessor.grammar.analysis.DepthFirstAdapter;
import gov.nasa.jpf.units.preprocessor.grammar.node.ABaseUnit;
import gov.nasa.jpf.units.preprocessor.grammar.node.AClassDefCommon;
import gov.nasa.jpf.units.preprocessor.grammar.node.AConvertFloatConvert;
import gov.nasa.jpf.units.preprocessor.grammar.node.AConvertRationalConvert;
import gov.nasa.jpf.units.preprocessor.grammar.node.ADerivedUnit;
import gov.nasa.jpf.units.preprocessor.grammar.node.ADimensionlessUnit;
import gov.nasa.jpf.units.preprocessor.grammar.node.AEnumClassDef;
import gov.nasa.jpf.units.preprocessor.grammar.node.AExtraIdentifier;
import gov.nasa.jpf.units.preprocessor.grammar.node.APackageName;
import gov.nasa.jpf.units.preprocessor.grammar.node.AScaledUnitFloatScaledUnit;
import gov.nasa.jpf.units.preprocessor.grammar.node.AScaledUnitRationalScaledUnit;
import gov.nasa.jpf.units.preprocessor.grammar.node.AStringClassDef;
import gov.nasa.jpf.units.preprocessor.grammar.node.AUnitSpecElem;
import gov.nasa.jpf.units.preprocessor.grammar.node.PCmd;
import gov.nasa.jpf.units.preprocessor.grammar.node.PExtraIdentifier;
import gov.nasa.jpf.units.preprocessor.grammar.node.Start;
import gov.nasa.jpf.units.preprocessor.grammar.node.TIdentifier;
import gov.nasa.jpf.units.preprocessor.grammar.node.TKwConvert;
import gov.nasa.jpf.units.preprocessor.grammar.node.TKwScaled;
import gov.nasa.jpf.units.preprocessor.grammar.node.TStringLiteral;

import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.math3.fraction.Fraction;
import org.apache.commons.math3.fraction.FractionFormat;

/*
 * Walks the syntax tree generated by parser and digs out what we need
 * Checks for duplicate unit names, doesn't check circular dependencies
 * (ObjectifiedDefinition does that)
 */
public class TextualDefinition extends DepthFirstAdapter {

  /*
   * Represents a single unit entry in the processed file
   */
  public abstract static class FileEntry_Unit {
    public final String Name;
    public final String ShortName;
    public final String ShortNameLiteral;
    public final int Line;

    private String parseShortId(String shortIdLiteral) {
      String shortId = shortIdLiteral;
      shortId = shortId.substring(1, shortId.length() - 1);
      shortId = shortId.replaceAll("\\\\\\\\", "\\\\"); // handles escaped backslash
      shortId = shortId.replaceAll("\\\\\"", "\\\""); // handles escaped double quote
      return shortId;
    }

    public FileEntry_Unit(String name, String shortNameLiteral, int line) {
      Name = name;
      ShortNameLiteral = shortNameLiteral;
      ShortName = parseShortId(shortNameLiteral);
      Line = line;
    }
  }

  public static class FileEntry_DimensionlessUnit extends FileEntry_Unit {
    public FileEntry_DimensionlessUnit(String name, String shortNameLiteral, int line) {
      super(name, shortNameLiteral, line);
    }
  }

  public static class FileEntry_BaseUnit extends FileEntry_Unit {
    public FileEntry_BaseUnit(String name, String shortNameLiteral, int line) {
      super(name, shortNameLiteral, line);
    }
  }

  public static class FileEntry_DerivedUnit extends FileEntry_Unit {
    public final List<FileEntry_SubUnit> SubUnits;

    public FileEntry_DerivedUnit(String name, String shortNameLiteral, int line, List<FileEntry_SubUnit> subUnits) {
      super(name, shortNameLiteral, line);
      SubUnits = subUnits;
    }
  }

  public static class FileEntry_ScaledUnit extends FileEntry_Unit {
    public final String OriginalUnit;
    public final double Coefficient;

    public FileEntry_ScaledUnit(String name, String shortNameLiteral, int line, String originalUnit, double coefficient) {
      super(name, shortNameLiteral, line);
      OriginalUnit = originalUnit;
      Coefficient = coefficient;
    }

  }

  /*
   * Represents an item in derived unit's list of sub units
   */
  public static class FileEntry_SubUnit {
    public final String Name;
    public final Fraction Dimension;
    public final int Line;

    public FileEntry_SubUnit(String name, Fraction dimension, int line) {
      Name = name;
      Dimension = dimension;
      Line = line;
    }
  }

  public static class FileEntry_Conversion {
    public final String Name_Left;
    public final String Name_Right;
    public final double Coefficient;
    public final int Line;

    public FileEntry_Conversion(String nameLeft, String nameRight, double coefficient, int line) {
      Name_Left = nameLeft;
      Name_Right = nameRight;
      Coefficient = coefficient;
      Line = line;
    }
  }

  private String PackageName;
  private String ClassName;
  private Map<String, FileEntry_Unit> Units;
  private List<FileEntry_Conversion> Conversions;
  private UnitIdentifierType ClassType = UnitIdentifierType.EnumConstant;

  public TextualDefinition(Start syntaxTree) {
    syntaxTree.apply(this);
  }

  private static Fraction parseFraction(String text) {
    FractionFormat ff = new FractionFormat();
    return ff.parse(text);
  }

  @Override
  public void caseAPackageName(APackageName node) {
    // need to build the package name from identifiers separated by dots
    final StringBuilder str = new StringBuilder();
    str.append(node.getIdentifier().getText()); // first identifier is always there

    // now walk each extra identifier and add its name to the full package name
    for (PExtraIdentifier extra : node.getExtraIdentifiers()) {
      extra.apply(new DepthFirstAdapter() {
        @Override
        public void caseAExtraIdentifier(AExtraIdentifier node) {
          str.append(".");
          str.append(node.getIdentifier().getText());
        }
      });
    }

    PackageName = str.toString();
  }

  public FileEntry_Unit getFileEntry(String name) {
    return Units.get(name);
  }

  private void checkUnitIdUnique(String name, int line) throws PreprocessorException {
    FileEntry_Unit existing = getFileEntry(name);
    if (existing != null)
      throw new PreprocessorException("Line " + line + ": Unit \"" + name + "\" is already defined on line " + existing.Line);
  }

  private void checkUnitDefined(String name, int line) throws PreprocessorException {
    if (getFileEntry(name) == null)
      throw new PreprocessorException("Line " + line + ": Unit \"" + name + "\" cannot be resolved.");
  }

  private void checkUnitForDerivationNotScaled(String name, int line) throws PreprocessorException {
    if (getFileEntry(name) instanceof FileEntry_ScaledUnit)
      throw new PreprocessorException("Line " + line + ": Cannot use the scaled unit \"" + name + "\" here.");
  }

  private void checkUnitShortIdLiteralUnique(String nameLiteral, int line) {
    for (FileEntry_Unit existing : Units.values())
      if (existing.ShortNameLiteral.equals(nameLiteral))
        throw new PreprocessorException("Line " + line + ": Unit with short ID \"" + nameLiteral + "\" is already defined on line " + existing.Line);
  }

  private void checkConversionUnique(String nameLeft, String nameRight, int line) throws PreprocessorException {
    boolean foundOne = false;
    for(FileEntry_Conversion existing : Conversions) {
      if ((nameLeft.equals(existing.Name_Left) && nameRight.equals(existing.Name_Right)) ||
          (nameLeft.equals(existing.Name_Right) && nameRight.equals(existing.Name_Left))) {
        if (foundOne)
          throw new PreprocessorException("Line " + line + ": Conversion between \"" + nameLeft + "\" and \"" + nameRight + "\" is already defined on line " + existing.Line);
        else
          foundOne = true;
      }
    }
  }

  private String parseId(TIdentifier idToken) {
    String id = idToken.getText();
    int line = idToken.getLine();
    checkUnitIdUnique(id, line);
    return id;
  }

  private String parseShortIdLiteral(TStringLiteral shortIdToken, TIdentifier idToken) {
    String shortId;
    if (shortIdToken == null) {
      shortId = "\"" + idToken.getText() + "\"";
      checkUnitShortIdLiteralUnique(shortId, idToken.getLine());
    } else {
      shortId = shortIdToken.getText();
      checkUnitShortIdLiteralUnique(shortId, shortIdToken.getLine());
    }
    return shortId;
  }

  @Override
  public void caseAEnumClassDef(AEnumClassDef node) {
    ClassType = UnitIdentifierType.EnumConstant;
    super.caseAEnumClassDef(node);
  }

  @Override
  public void caseAStringClassDef(AStringClassDef node) {
    ClassType = UnitIdentifierType.String;
    super.caseAStringClassDef(node);
  }

  @Override
  public void caseAClassDefCommon(AClassDefCommon node) {
    // class name is a single identifier, easy...
    ClassName = node.getIdentifier().getText();

    // init units list
    Units = new LinkedHashMap<String, FileEntry_Unit>();

    // init conversions list
    Conversions = new LinkedList<FileEntry_Conversion>();

    // parse all the units
    for (PCmd cmd : node.getCommands())
      cmd.apply(new DepthFirstAdapter() {
      @Override
      public void caseADimensionlessUnit(ADimensionlessUnit node) {
        TIdentifier idToken = node.getId();
        String id = parseId(idToken);
        String shortIdLiteral = parseShortIdLiteral(node.getShortId(), idToken);
        int line = node.getKwDimensionless().getLine();
        Units.put(id, new FileEntry_DimensionlessUnit(id, shortIdLiteral, line));
      }

      @Override
      public void caseABaseUnit(ABaseUnit node) {
        TIdentifier idToken = node.getId();
        String id = parseId(idToken);
        String shortIdLiteral = parseShortIdLiteral(node.getShortId(), idToken);
        int line = node.getKwBase().getLine();
        Units.put(id, new FileEntry_BaseUnit(id, shortIdLiteral, line));
      }

      @Override
      public void caseADerivedUnit(ADerivedUnit node) {
        // first read the identifier
        TIdentifier idToken = node.getId();
        String id = parseId(idToken);
        String shortIdLiteral = parseShortIdLiteral(node.getShortId(), idToken);
        int line = node.getKwDerived().getLine();

        // then read the specification
        final List<FileEntry_SubUnit> spec = new LinkedList<FileEntry_SubUnit>();
        node.getUnitSpec().apply(new DepthFirstAdapter() {
          @Override
          public void caseAUnitSpecElem(AUnitSpecElem node) {
            spec.add(new FileEntry_SubUnit(
                       node.getUnitId().getText(),
                       parseFraction(node.getCoefficient().getText()),
                       node.getUnitId().getLine()));
          }
        });

        // combine and add to list
        Units.put(id, new FileEntry_DerivedUnit(id, shortIdLiteral, line, spec));
      }

      private void processScaledUnit(TKwScaled keyword, TIdentifier idLeft, TIdentifier idRight, double coefficient) {
        String id = parseId(idLeft);
        String shortId = parseShortIdLiteral(null, idLeft);
        String originalUnit = idRight.getText();
        int line = keyword.getLine();

        Units.put(id, new FileEntry_ScaledUnit(id, shortId, line, originalUnit, coefficient));
      }

      @Override
      public void caseAScaledUnitRationalScaledUnit(AScaledUnitRationalScaledUnit node) {
        processScaledUnit(
          node.getKwScaled(),
          node.getIdLeft(),
          node.getIdRight(),
          parseFraction(node.getCoefficient().getText()).doubleValue());
      }

      @Override
      public void caseAScaledUnitFloatScaledUnit(AScaledUnitFloatScaledUnit node) {
        processScaledUnit(
          node.getKwScaled(),
          node.getIdLeft(),
          node.getIdRight(),
          Double.parseDouble(node.getCoefficient().getText()));
      }

      private void processConversion(TKwConvert keyword, TIdentifier idLeft, TIdentifier idRight, double coefficient) {
        String nameLeft = idLeft.getText();
        String nameRight = idRight.getText();
        int line = keyword.getLine();

        Conversions.add(new FileEntry_Conversion(nameLeft, nameRight, coefficient, line));
      }

      @Override
      public void caseAConvertRationalConvert(AConvertRationalConvert node) {
        processConversion(
          node.getKwConvert(),
          node.getIdLeft(),
          node.getIdRight(),
          parseFraction(node.getCoefficient().getText()).doubleValue());
      }

      @Override
      public void caseAConvertFloatConvert(AConvertFloatConvert node) {
        processConversion(
          node.getKwConvert(),
          node.getIdLeft(),
          node.getIdRight(),
          Double.parseDouble(node.getCoefficient().getText()));
      }
    });

    // check all the referenced units
    for (FileEntry_Unit unit : Units.values()) {
      if (unit instanceof FileEntry_ScaledUnit) {
        FileEntry_ScaledUnit scaledUnit = (FileEntry_ScaledUnit) unit;
        checkUnitDefined(scaledUnit.OriginalUnit, scaledUnit.Line);
      } else if (unit instanceof FileEntry_DerivedUnit) {
        FileEntry_DerivedUnit derivedUnit = (FileEntry_DerivedUnit) unit;
        for (FileEntry_SubUnit subUnit : derivedUnit.SubUnits) {
          checkUnitDefined(subUnit.Name, subUnit.Line);
          checkUnitForDerivationNotScaled(subUnit.Name, subUnit.Line);
        }
      }
    }

    // check references in conversions
    for (FileEntry_Conversion conv : Conversions) {
      checkUnitDefined(conv.Name_Left, conv.Line);
      checkUnitForDerivationNotScaled(conv.Name_Left, conv.Line);
      checkUnitDefined(conv.Name_Right, conv.Line);
      checkUnitForDerivationNotScaled(conv.Name_Right, conv.Line);
      checkConversionUnique(conv.Name_Left, conv.Name_Right, conv.Line);
    }
  }

  public String getPackageName() {
    return PackageName;
  }

  public String getClassName() {
    return ClassName;
  }

  public UnitIdentifierType getClassType() {
    return ClassType;
  }

  public Set<String> getListOfUnits() {
    return new LinkedHashSet<String>(Units.keySet());
  }

  public List<FileEntry_Conversion> getListOfConversions() {
    return Conversions;
  }
}
