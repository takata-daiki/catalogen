package net.sf.colossus.server;


import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.JOptionPane;

import net.sf.colossus.client.HexMap;
import net.sf.colossus.common.Constants;
import net.sf.colossus.common.Options;
import net.sf.colossus.common.WhatNextManager;
import net.sf.colossus.common.WhatNextManager.WhatToDoNext;
import net.sf.colossus.game.BattlePhase;
import net.sf.colossus.game.Caretaker;
import net.sf.colossus.game.Creature;
import net.sf.colossus.game.EntrySide;
import net.sf.colossus.game.Game;
import net.sf.colossus.game.Legion;
import net.sf.colossus.game.Phase;
import net.sf.colossus.game.Player;
import net.sf.colossus.game.PlayerColor;
import net.sf.colossus.game.Proposal;
import net.sf.colossus.server.BattleServerSide.AngelSummoningStates;
import net.sf.colossus.util.ErrorUtils;
import net.sf.colossus.util.InstanceTracker;
import net.sf.colossus.util.Split;
import net.sf.colossus.util.StaticResourceLoader;
import net.sf.colossus.util.ViableEntityManager;
import net.sf.colossus.variant.BattleHex;
import net.sf.colossus.variant.CreatureType;
import net.sf.colossus.variant.MasterBoardTerrain;
import net.sf.colossus.variant.MasterHex;
import net.sf.colossus.webclient.WebClient;
import net.sf.colossus.xmlparser.TerrainRecruitLoader;

import org.jdom.Attribute;
import org.jdom.CDATA;
import org.jdom.DataConversionException;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;


/**
 * Class Game gets and holds high-level data about a Titan game.
 *
 * This is the old design with the game information in the server. Some
 * of the functionality here is supposed to be moved into the {@link net.sf.colossus.game.Game}
 * class which then can be shared between server and clients (the class, not the instances).
 * Other parts should be moved into the {@link Server} class or elsewhere.
 *
 * @version $Id: GameServerSide.java 4133 2009-04-30 12:50:45Z dolbeau $
 * @author David Ripton
 * @author Bruce Sherrod
 * @author Romain Dolbeau
 */

public final class GameServerSide extends Game
{
    private static final Logger LOGGER = Logger.getLogger(GameServerSide.class
        .getName());

    private int activePlayerNum;
    private int turnNumber; // Advance when every player has a turn
    private int lastRecruitTurnNumber;
    private boolean engagementInProgress;
    private boolean battleInProgress;
    private boolean summoning;
    private boolean reinforcing;
    private boolean acquiring;
    private int pointsScored;
    private int turnCombatFinished;
    private Legion winner;
    private String engagementResult;
    private boolean pendingAdvancePhase;

    private boolean loadingGame;
    private boolean replayOngoing = false;
    private BattleServerSide battle;
    private Phase phase;
    private Server server;
    // Negotiation
    private final Set<Proposal> attackerProposals = new HashSet<Proposal>();
    private final Set<Proposal> defenderProposals = new HashSet<Proposal>();

    private final LinkedList<Player> colorPickOrder = new LinkedList<Player>();
    private List<PlayerColor> colorsLeft;
    private final PhaseAdvancer phaseAdvancer = new GamePhaseAdvancer();
    private final Options options;

    private String hostingPlayerName = null;
    private String flagFilename = null;
    private NotifyWebServer notifyWebServer = null;
    private WebClient startingWebClient = null;

    private final WhatNextManager whatNextManager;
    private History history;

    private static int gameCounter = 1;
    private final String gameId;

    private boolean hotSeatMode = false;
    // currently visible board-player (for hotSeatMode)
    private Player cvbPlayer = null;

    private final List<String> autoGeneratedFiles = new ArrayList<String>();

    /** Shortcut for UnitTests,
     *  to create a Game with dummy input objects on the fly.
     */
    static GameServerSide makeNewGameServerSide()
    {
        Options startOptions = new Options(Constants.OPTIONS_START);
        WhatNextManager whatNextManager = new WhatNextManager(startOptions);

        Options serverOptions = new Options("UnitTest", true);
        return new GameServerSide(whatNextManager, serverOptions);
    }

    /** The normal constructor to be used everywhere
     *
     * @param startObj  The 'Start' object that started this game, and thus
     * manages the main control flow which thing to do 'next' when this game
     * is over.
     * @param serverOptions The server side options, initialized from the
     * GetPlayers dialog and/or command line options.
     */
    GameServerSide(WhatNextManager whatNextMgr, Options serverOptions)
    {
        super(null, new String[0]);
        // later perhaps from command line, GUI, or WebServer set it?
        gameId = "#" + (gameCounter++);
        this.whatNextManager = whatNextMgr;
        this.options = serverOptions;

        InstanceTracker.register(this, "Game at port " + getPort());

        // The caretaker object was created by super(...)
        getCaretaker().addListener(new Caretaker.ChangeListener()
        {
            public void creatureTypeAvailabilityUpdated(CreatureType type,
                int availableCount)
            {
                updateCaretakerDisplaysFor(type);
            }

            public void creatureTypeDeadCountUpdated(CreatureType type,
                int deadCount)
            {
                updateCaretakerDisplaysFor(type);
            }

            public void fullUpdate()
            {
                updateCaretakerDisplays();
            }

        });
    }

    public void setFlagFilename(String flagFilename)
    {
        this.flagFilename = flagFilename;
    }

    public String getHostingPlayer()
    {
        return hostingPlayerName;
    }

    private int getPort()
    {
        int port = options.getIntOption(Options.serveAtPort);
        if (port < 0)
        {
            port = Constants.defaultPort;
        }
        return port;
    }

    private void initServer()
    {
        // create it even if not needed (=no web server).
        // This way we can have all the "if <there is a webserver>"
        // wrappers inside the notify Class, instead spread over the code...
        notifyWebServer = new NotifyWebServer(flagFilename);

        if (server != null)
        {
            server.setObsolete();
            server.disposeAllClients();
        }
        server = new Server(this, whatNextManager, getPort());
        if (startingWebClient != null)
        {
            startingWebClient.setLocalServer(server);
        }
        try
        {
            // Clemens 12/2007:
            // initFileServer can now done before creating local clients,
            // starting the ClientHandlers and accepting the clients.
            // It decides whether to start a FST or not based on whether there
            // are *Network type* players in the Player list (instead of
            // whether there is something in the socket list, which was bogus,
            // because also local clients will be in socket list).
            // It's also not necessary to be after the socket server-start
            //   / client-accepting, "because FST accepts only request from known
            //       client addresses"  -- in fact a client won't request files
            // before he is registered. So, do the FST start first and we are safe.
            server.initFileServer();
            server.initSocketServer();
            notifyWebServer.readyToAcceptClients();
            if (server.waitForClients())
            {
                ViableEntityManager.register(this, "Server/Game " + gameId);

                // Note server.start() is done even if not all clients came in.
                // This is needed to that run() after the loop notifies that
                // the game is over.
                server.start();

                if (startingWebClient != null)
                {
                    // Tell WebClient to inform the WebServer that the game
                    // was started (on this player's PC) and all clients have
                    // connected (WebClients updates the status in bottom row
                    // then).
                    startingWebClient.informGameStartedLocally();
                }
            }
            else
            {
                // Note server.start() is done even if not all clients came in.
                // This is needed to that run() after the loop notifies that
                // the game is over.
                server.start();
            }

        }
        catch (Exception e)
        {
            LOGGER.log(Level.SEVERE, "Server initialization got Exception "
                + e.getMessage(), e);
        }
    }

    /**
     * Update the dead and available counts for a creature type on all clients.
     */
    private void updateCaretakerDisplaysFor(CreatureType type)
    {
        if (replayOngoing)
        {
            return;
        }
        if (server != null)
        {
            server.allUpdateCreatureCount(type, getCaretaker()
                .getAvailableCount(type), getCaretaker().getDeadCount(type));
        }
    }

    /**
     * Update the dead and available counts for all creature types on all clients.
     */
    private void updateCaretakerDisplays()
    {
        if (replayOngoing)
        {
            return;
        }
        for (CreatureType type : getVariant().getCreatureTypes())
        {
            updateCaretakerDisplaysFor(type);
        }
    }

    private void cleanupWhenGameOver()
    {
        server.waitUntilGameFinishes();
        server.cleanup();
        server = null;

        ViableEntityManager.unregister(this);
    }

    private void clearFlags()
    {
        engagementInProgress = false;
        battleInProgress = false;
        summoning = false;
        reinforcing = false;
        acquiring = false;
        pendingAdvancePhase = false;
        loadingGame = false;
        engagementResult = null;
    }

    private void addPlayersFromOptions()
    {
        for (int i = 0; i < VariantSupport.getMaxPlayers(); i++)
        {
            String name = options.getStringOption(Options.playerName + i);
            String type = options.getStringOption(Options.playerType + i);

            if (name != null && type != null && !type.equals(Constants.none))
            {
                addPlayer(name, type);
                LOGGER.info("Added " + type + " player " + name);
            }
        }
        // No longer need the player name and type options.
        options.clearPlayerInfo();

        getVariant().getCreatureByName("Titan").setMaxCount(getNumPlayers());
    }

    /** Start a new game. */
    void newGame(String hostingPlayer, WebClient webClient)
    {
        hostingPlayerName = hostingPlayer;
        if (webClient != null)
        {
            startingWebClient = webClient;
        }
        else
        {
            // In case game was started by WebClient locally on user's
            // computer, WebClient cannot be passed into the GameServerSide
            // (to do so, the IStartHandler interfact would need to import the
            // WebClient class, and then we would have a cyclic dependency).
            // So, the initiating WebClient stores itself into a static
            // variable which we query here.
            startingWebClient = WebClient.getInitiatingWebClient();
        }

        clearFlags();

        turnNumber = 1;
        lastRecruitTurnNumber = -1;
        phase = Phase.SPLIT;
        players.clear();

        VariantSupport.loadVariantByName(options
            .getStringOption(Options.variant), true);

        LOGGER.info("Starting new game");

        CustomRecruitBase.resetAllInstances();
        CustomRecruitBase.setGame(this);

        addPlayersFromOptions();
        // reset the caretaker after we have the players to get the right Titan counts
        getCaretaker().resetAllCounts();

        hotSeatMode = options.getOption(Options.hotSeatMode);

        history = new History();

        initServer();
        // Some more stuff is done from newGame2() when the last
        // expected client has connected.
        // Main thread has now nothing to do any more, can wait
        // until game finishes.

        if (server.isServerRunning())
        {
            cleanupWhenGameOver();
        }
        else
        {
            server.cleanup();
            server = null;
        }
    }

    /* Called from the last ClientHandler connecting
     *  ( = when expected nr. of clients has connected).
     */
    void newGame2()
    {
        // We need to set the autoPlay option before loading the board,
        // so that we can avoid showing boards for AI players.
        syncAutoPlay();
        syncOptions();
        server.allInitBoard();
        assignTowers();

        // Renumber players in descending tower order.
        sortPlayersDescendingTower();
        activePlayerNum = 0;
        assignColors();
    }

    /**
     * Temporary solution ... I do not know a better way how to do the
     * sorting on players (type List<Player>) itself.
     * I don't want to pull up the Comparator predicate, because
     * ClientSide might have totally different idea of the right "order"...
     */
    private void sortPlayersDescendingTower()
    {
        List<PlayerServerSide> playersSS = new ArrayList<PlayerServerSide>();
        for (Player p : getPlayers())
        {
            playersSS.add((PlayerServerSide)p);
        }
        Collections.sort(playersSS);
        players.clear();
        for (PlayerServerSide p : playersSS)
        {
            players.add(p);
        }
    }

    private boolean nameIsTaken(String name, Player checkedPlayer)
    {
        for (int i = 0; i < getNumPlayers(); i++)
        {
            Player player = players.get(i);
            if (player.getName().equals(name) && !player.equals(checkedPlayer))
            {
                return true;
            }
        }
        return false;
    }

    /** If the name is taken, add random digits to the end. */
    String getUniqueName(final String name, Player player)
    {
        if (!nameIsTaken(name, player))
        {
            return name;
        }
        return getUniqueName(name + Dice.rollDie(), player);
    }

    /** Find a Player for a new remote client.
     *  If loading a game, this is the network player with a matching
     *  player name.  If a new game, it's the first network player whose
     *  name is still set to <By client> */
    Player findNetworkPlayer(final String playerName)
    {
        for (int i = 0; i < getNumPlayers(); i++)
        {
            Player curPlayer = players.get(i);

            if (curPlayer.getType().endsWith(Constants.network))
            {
                if (isLoadingGame())
                {
                    if (curPlayer.getName().equals(playerName))
                    {
                        return curPlayer;
                    }
                }
                else
                {
                    if (curPlayer.getName().startsWith(Constants.byClient))
                    {
                        curPlayer.setName(playerName);
                        return curPlayer;
                    }
                }
            }
        }
        return null;
    }

    private void syncAutoPlay()
    {
        for (Player player : getPlayers())
        {
            server.oneSetOption(player, Options.autoPlay, player.isAI());
            server.oneSetOption(player, Options.playerType, player.getType());
        }
    }

    /** Send all current game option values to all clients. */
    private void syncOptions()
    {
        Enumeration<String> en = options.propertyNames();

        while (en.hasMoreElements())
        {
            String name = en.nextElement();
            String value = options.getStringOption(name);

            server.allSyncOption(name, value);
        }
    }

    private void assignColors()
    {
        List<PlayerColor> cli = new ArrayList<PlayerColor>(Arrays
            .asList(PlayerColor.values()));

        colorsLeft = new ArrayList<PlayerColor>();

        /* Add the first 6 colors in random order, ... */
        for (int i = 0; i < Constants.DEFAULT_MAX_PLAYERS; i++)
        {
            colorsLeft.add(cli.remove(Dice
                .rollDie(Constants.DEFAULT_MAX_PLAYERS - i) - 1));
        }

        /* ... and finish with the newer ones, also in random order */
        int newer = cli.size();

        for (int i = 0; i < newer; i++)
        {
            colorsLeft.add(cli.remove(Dice.rollDie(newer - i) - 1));
        }

        // Let human players pick colors first, followed by AI players.
        // Within each group, players pick colors in ascending tower order.
        colorPickOrder.clear();

        for (int i = getNumPlayers() - 1; i >= 0; i--)
        {
            Player player = players.get(i);

            if (player.isHuman())
            {
                colorPickOrder.add(player);
            }
        }
        for (int i = getNumPlayers() - 1; i >= 0; i--)
        {
            Player player = players.get(i);

            if (player.isAI())
            {
                colorPickOrder.add(player);
            }
        }

        nextPickColor();
    }

    void nextPickColor()
    {
        if (colorPickOrder.size() >= 1)
        {
            Player playerName = colorPickOrder.getFirst();

            server.askPickColor(playerName, colorsLeft);
        }
        else
        {
            // All players are done picking colors; continue.
            newGame3();
        }
    }

    private String makeNameByType(String templateName, String type)
    {
        String number = templateName.substring(Constants.byType.length());
        // type is the full class name of client, e.g.
        //   "net.sf.colossus.ai.SimpleAI"
        String prefix = Constants.aiPackage;
        int len = prefix.length();

        String shortName = type.substring(len);
        String newName;

        if (shortName.equals("Human"))
        {
            newName = "Human" + number;
        }
        else if (shortName.equals("SimpleAI"))
        {
            newName = "Simple" + number;
        }
        else if (shortName.equals("CowardSimpleAI"))
        {
            newName = "Coward" + number;
        }
        else if (shortName.equals("RationalAI"))
        {
            newName = "Rational" + number;
        }
        else if (shortName.equals("HumanHaterRationalAI"))
        {
            newName = "Hater" + number;
        }
        else if (shortName.equals("MilvangAI"))
        {
            newName = "Milvang" + number;
        }
        else if (shortName.equals("ExperimentalAI"))
        {
            newName = "Experimental" + number;
        }
        else
        {
            newName = null;
        }
        return newName;
    }

    void assignColor(Player player, PlayerColor color)
    {
        colorPickOrder.remove(player);
        colorsLeft.remove(color);
        ((PlayerServerSide)player).setColor(color);
        String type = ((PlayerServerSide)player).getType();
        String gotName = player.getName();
        if (gotName.startsWith(Constants.byType))
        {
            String newName = makeNameByType(gotName, type);
            if (newName != null)
            {
                LOGGER.info("Setting for \"" + gotName + "\" new name: "
                    + newName);
                server.setPlayerName(player, newName);
                player.setName(newName);
            }
            else
            {
                LOGGER.log(Level.WARNING, "Type " + type + " not recognized"
                    + ". Giving name by color instead (" + color + ")");
                gotName = Constants.byColor;
            }
        }

        if (gotName.startsWith(Constants.byColor))
        {
            server.setPlayerName(player, color.getName());
            player.setName(color.getName());
        }
        LOGGER.info(player + " chooses color " + color);
        ((PlayerServerSide)player).initMarkersAvailable();
        server.allUpdatePlayerInfo();
        server.askPickFirstMarker(player);
    }

    Player getNextColorPicker()
    {
        return colorPickOrder.getFirst();
    }

    /** Done picking player colors; proceed to start game. */
    private void newGame3()
    {
        server.allUpdatePlayerInfo();

        for (Player p : getPlayers())
        {
            PlayerServerSide player = (PlayerServerSide)p;
            placeInitialLegion(player, player.getFirstMarker());
            server.allRevealLegion(player.getLegions().get(0),
                Constants.reasonInitial);
            server.allUpdatePlayerInfo();
        }

        server.allTellAllLegionLocations();
        autoSave();
        updateCaretakerDisplays();
        server.allRequestConfirmCatchup("KickstartGame");
    }

    /** Randomize towers by rolling dice and rerolling ties. */
    private void assignTowers()
    {
        int numPlayers = getNumPlayers();
        MasterHex[] playerTower = new MasterHex[numPlayers];
        Set<MasterHex> towerSet = getVariant().getMasterBoard().getTowerSet();

        // first create a list with all tower hexes
        List<MasterHex> towerList = new ArrayList<MasterHex>(towerSet);

        if (getOption(Options.balancedTowers))
        {
            towerList = getBalancedTowers(numPlayers, towerList);
        }

        int playersLeft = numPlayers - 1;

        while ((playersLeft >= 0) && (!towerList.isEmpty()))
        {
            int which = Dice.rollDie(towerList.size());
            playerTower[playersLeft] = towerList.remove(which - 1);
            playersLeft--;
        }

        for (int i = 0; i < numPlayers; i++)
        {
            Player player = players.get(i);
            LOGGER.info(player + " gets tower " + playerTower[i]);
            player.setStartingTower(playerTower[i]);
        }
    }

    /** Return a list with a balanced order of numPlayer towers chosen
     from towerList, which must hold numeric strings. */
    static List<MasterHex> getBalancedTowers(int numPlayers,
        final List<MasterHex> towerList)
    {
        int numTowers = towerList.size();

        if (numPlayers > numTowers)
        {
            LOGGER.log(Level.SEVERE, "More players than towers!");
            return towerList;
        }

        // Make a sorted copy, converting String to Integer.
        ArrayList<Integer> numericList = new ArrayList<Integer>();

        for (MasterHex tower : towerList)
        {
            Integer i = new Integer(tower.getLabel());

            numericList.add(i);
        }
        Collections.sort(numericList);

        double towersPerPlayer = (double)numTowers / numPlayers;

        // First just find a balanced sequence starting at zero.
        double counter = 0.0;
        int numDone = 0;
        List<Integer> sequence = new ArrayList<Integer>();
        // Prevent floating-point roundoff error.
        double epsilon = 0.0000001;

        while (numDone < numPlayers)
        {
            sequence.add(Integer.valueOf((int)Math.floor(counter + epsilon)));
            numDone++;
            counter += towersPerPlayer;
        }

        // Pick a random starting point.  (Zero-based)
        int startingTower = Dice.rollDie(numTowers) - 1;

        // Offset the sequence by the starting point, and get only
        // the number of starting towers we need.
        List<MasterHex> returnList = new ArrayList<MasterHex>();

        Iterator<Integer> it = sequence.iterator();
        numDone = 0;
        while (it.hasNext() && numDone < numPlayers)
        {
            Integer raw = it.next();
            int cooked = (raw.intValue() + startingTower) % numTowers;
            Integer numericLabel = numericList.get(cooked);

            returnList.add(VariantSupport.getCurrentVariant().getMasterBoard()
                .getHexByLabel(numericLabel.toString()));
            numDone++;
        }
        return returnList;
    }

    Server getServer()
    {
        return server;
    }

    PlayerServerSide addPlayer(String name, String shortTypeName)
    {
        PlayerServerSide player = new PlayerServerSide(name, this,
            shortTypeName);

        players.add(player);
        return player;
    }

    Player getActivePlayer()
    {
        // Sanity check in case called before all players are loaded.
        if (activePlayerNum < players.size())
        {
            return players.get(activePlayerNum);
        }
        else
        {
            return null;
        }
    }

    /**
     * Resolve playerName into Player object. Name might be null,
     * then returns null.
     * @param playerName
     * @return The player object for given player name, null if name was null
     */
    Player getPlayerByNameIgnoreNull(String playerName)
    {
        if (playerName == null)
        {
            return null;
        }
        else
        {
            return getPlayerByName(playerName);
        }
    }

    /**
     * Resolve playerName into Player object.
     * Name must not be null. If no player for given name found,
     * it would throw IllegalArgumentException
     * @param playerName
     * @return Player object for given name.
     */
    Player getPlayerByName(String playerName)
    {
        assert playerName != null : "Name for player to find must not be null!";

        for (Player player : players)
        {
            if (player.getName().equals(playerName))
            {
                return player;
            }
        }
        throw new IllegalArgumentException("No player object found for name '"
            + playerName + "'");
    }

    /**
     *  NOTE: to be used only during loading a Game!
     *  Client side has a more sophisticated version that takes
     *  slain players and their inherited markers into account.
     */
    Player getPlayerByShortColor(String shortColor)
    {
        if (shortColor != null)
        {
            for (Player player : getPlayers())
            {
                if (shortColor.equals(player.getShortColor()))
                {
                    return player;
                }
            }
        }
        return null;
    }

    /**
     * A player requested he wants to withdraw (or connection was lost, and
     * server socket handling does withdraw then).
     *
     * @param player The player that wishes to withdraw from the game
     *
     * TODO Notify all players.
     */
    void handlePlayerWithdrawal(Player player)
    {
        String name = player.getName();

        if (player.isDead())
        {
            LOGGER.log(Level.FINE, "Nothing to do for withdrawal of player "
                + name + " - is already dead.");
            return;
        }

        LOGGER.log(Level.FINE, "Player " + name + " withdraws from the game.");

        // If player quits while engaged, set slayer.
        Player slayer = null;
        Legion legion = player.getTitanLegion();
        if (legion != null && isEngagement(legion.getCurrentHex()))
        {
            slayer = getFirstEnemyLegion(legion.getCurrentHex(), player)
                .getPlayer();
        }
        ((PlayerServerSide)player).die(slayer);
        checkForVictory();

        // checks if game over state is reached, and if yes, announces so;
        // and returns false.
        // Otherwise it returns true and that means game shall go on.
        if (gameShouldContinue())
        {
            if (player == getActivePlayer())
            {
                advancePhase(getPhase(), player);
            }
        }
    }

    private Player getWinner()
    {
        int remaining = 0;
        Player result = null;
        for (Player player : getPlayers())
        {
            if (!player.isDead())
            {
                remaining++;
                if (remaining > 1)
                {
                    return null;
                }
                else
                {
                    result = player;
                }
            }
        }
        return result;
    }

    // TODO Up to game.Game or not?
    //      In practice it is only needed in server side.
    void checkForVictory()
    {
        if (isGameOver())
        {
            LOGGER
                .severe("checkForVictory called although game is already over!!");
            return;
        }

        int remaining = getNumLivingPlayers();

        switch (remaining)
        {
            case 0:
                LOGGER.info("Reached game over state -- Draw at "
                    + new Date().getTime());
                setGameOver(true, "Draw");
                break;

            case 1:
                String winnerName = getWinner().getName();
                LOGGER.info("Reached game over state -- " + winnerName
                    + " wins at " + new Date().getTime());
                setGameOver(true, winnerName + " wins");
                break;

            default:
                break;
        }
    }

    private void announceGameOver(boolean disposeFollows)
    {
        server.allFullyUpdateAllLegionContents(Constants.reasonGameOver);
        LOGGER.info("Announcing: Game over -- " + getGameOverMessage());
        server.allTellGameOver(getGameOverMessage(), disposeFollows);
    }

    boolean isLoadingGame()
    {
        return loadingGame;
    }

    public void kickstartGame()
    {
        LOGGER.info("All clients have caught up with loading/replay or "
            + "pickColor, now kicking off the Game!");
        setupPhase();
    }

    Phase getPhase()
    {
        return phase;
    }

    /**
     * Advance to the next phase, only if the passed oldPhase and playerName
     * are current.
     */
    void advancePhase(final Phase oldPhase, final Player player)
    {
        if (oldPhase != phase)
        {
            LOGGER.severe("Player " + player
                + " called advancePhase illegally (reason: " + "oldPhase ("
                + oldPhase + ") != phase (" + phase + "))");
            return;
        }
        if (pendingAdvancePhase)
        {
            LOGGER
                .severe("Player "
                    + player
                    + " called advancePhase illegally (reason: pendingAdvancePhase is true)");
            return;
        }
        if (!player.equals(getActivePlayer()))
        {
            LOGGER.severe("Player " + player
                + " called advancePhase illegally (reason: "
                + "wrong player [" + player + " vs. " + getActivePlayer()
                + "])");
            return;
        }
        if (getOption(Options.autoStop) && onlyAIsRemain()
            && !isGameOver())
        {
            LOGGER.info("Not advancing because no humans remain");
            setGameOver(true, "All humans eliminated");
        }

        if (gameShouldContinue())
        {
            phaseAdvancer.advancePhase();
        }
    }

    /** Wrap the complexity of phase advancing. */
    class GamePhaseAdvancer implements PhaseAdvancer
    {

        /** Advance to the next phase, only if the passed oldPhase and
         *  playerName are current. */
        public void advancePhase()
        {
            pendingAdvancePhase = true;
            advancePhaseInternal();
        }

        /** Advance to the next phase, with no error checking. */
        public void advancePhaseInternal()
        {
            Phase oldPhase = phase;
            if (oldPhase == Phase.SPLIT)
            {
                phase = Phase.MOVE;
            }
            else if (oldPhase == Phase.MOVE)
            {
                phase = Phase.FIGHT;
            }
            else if (oldPhase == Phase.FIGHT)
            {
                phase = Phase.MUSTER;
            }

            if (oldPhase == Phase.MUSTER
                || (getActivePlayer().isDead() && getNumLivingPlayers() > 0))
            {
                advanceTurn();
            }
            else
            {
                LOGGER.info("Phase advances to " + phase);
            }

            pendingAdvancePhase = false;
            setupPhase();
        }

        public void advanceTurn()
        {
            clearFlags();
            activePlayerNum++;
            if (activePlayerNum == getNumPlayers())
            {
                activePlayerNum = 0;
                turnNumber++;
                if (turnNumber - lastRecruitTurnNumber > 100
                    && Options.isStresstest())
                {
                    LOGGER.info("\nLast recruiting is 100 turns ago - "
                        + "exiting to prevent AIs from endlessly "
                        + "running around...\n");
                    System.exit(0);
                }
            }

            /* notify all CustomRecruitBase object that we change the
             active player, for bookkeeping purpose */
            CustomRecruitBase.everyoneAdvanceTurn(activePlayerNum);

            phase = Phase.SPLIT;
            if (getActivePlayer().isDead() && getNumLivingPlayers() > 0)
            {
                advanceTurn();
            }
            else
            {
                LOGGER.info(getActivePlayer() + "'s turn, number "
                    + turnNumber);
                autoSave();
            }
        }
    }

    private void setupPhase()
    {
        if (phase == Phase.SPLIT)
        {
            setupSplit();
        }
        else if (phase == Phase.MOVE)
        {
            setupMove();
        }
        else if (phase == Phase.FIGHT)
        {
            setupFight();
        }
        else if (phase == Phase.MUSTER)
        {
            setupMuster();
        }
        else
        {
            LOGGER.log(Level.SEVERE, "Bogus phase");
        }
    }

    private void setupSplit()
    {
        Player player = getActivePlayer();

        if (player == null)
        {
            LOGGER.log(Level.SEVERE, "No players");
            dispose();
            return;
        }
        ((PlayerServerSide)player).resetTurnState();
        server.allSetupSplit();
        if (hotSeatMode)
        {
            hotSeatModeChangeBoards();
        }
    }

    private void hotSeatModeChangeBoards()
    {
        Player activePlayer = getActivePlayer();

        // game just started - find the local player which shall
        // get the board first, and hide all other local ones.
        if (cvbPlayer == null)
        {
            int i;
            for (i = 0; i < getNumPlayers(); i++)
            {
                Player iPlayer = players.get(i);
                if (iPlayer.isLocalHuman() && !server.isClientGone(iPlayer))
                {
                    // This is a local alive player.
                    if (cvbPlayer == null)
                    {
                        cvbPlayer = iPlayer;
                        server.setBoardVisibility(iPlayer, true);
                    }
                    else
                    {
                        server.setBoardVisibility(iPlayer, false);
                    }
                }
            }
            return;
        }

        // otherwise, switch board to next, then and only then
        // if activePlayer is now the next local human which is
        // still connected ( = has not closed his board).
        if (activePlayer.isLocalHuman() && !server.isClientGone(activePlayer))
        {
            server.setBoardVisibility(cvbPlayer, false);
            server.setBoardVisibility(activePlayer, true);
            cvbPlayer = activePlayer;
        }
    }

    private void setupMove()
    {
        Player player = getActivePlayer();

        ((PlayerServerSide)player).rollMovement();
        server.allSetupMove();
    }

    private void setupFight()
    {
        server.allSetupFight();
        server.nextEngagement();
    }

    private void setupMuster()
    {
        Player player = getActivePlayer();
        ((PlayerServerSide)player).removeEmptyLegions();
        // If a player has been eliminated we can't count on his client
        // still being around to advance the turn.
        if (player.isDead())
        {
            advancePhase(Phase.MUSTER, player);
        }
        else
        {
            server.allSetupMuster();
        }
    }

    int getTurnNumber()
    {
        return turnNumber;
    }

    private String makeAutosaveFileName()
    {
        Date date = new Date();
        boolean withInfo = options.getOption(Options.autosaveVerboseNames,
            true);

        String infoPart = "";
        if (withInfo)
        {
            infoPart = "_" + getTurnNumber() + "-" + getActivePlayer() + "-"
                + getPhase();
        }

        String name = Constants.SAVE_DIR_NAME + Constants.XML_SNAPSHOT_START
            + date.getTime() + infoPart + Constants.XML_EXTENSION;
        return name;
    }

    void saveGameInTry(final String filename, boolean autoSave)
    {
        try
        {
            saveGame(filename, autoSave);
        }
        catch (Exception e)
        {
            String asNowOffMmessage = "";
            if (autoSave)
            {
                options.setOption(Options.autosave, false);
                asNowOffMmessage = " (autosave now disabled)";
            }

            String doWhat = autoSave ? "auto-save" : "save";
            String toWhere = filename == null ? "<automatically generated filename>"
                : (" file " + filename);
            String message = "Woooah! An exception was caught while "
                + "trying to " + doWhat + " game to " + toWhere
                + "\nStack trace:\n" + ErrorUtils.makeStackTraceString(e)
                + "\nSaving the game did probably not succeed"
                + asNowOffMmessage + ".\n";
            LOGGER.warning(message);
            ErrorUtils.showExceptionDialog(null, message,
                "Exception caught during saving!", false);
        }
    }

    private synchronized void saveGame(final String filename, boolean autoSave)
    {
        int keep = options.getIntOption(Options.autosaveMaxKeep);
        String fn = null;

        if (filename == null || filename.equals("null"))
        {
            File savesDir = new File(Constants.SAVE_DIR_NAME);

            if (!savesDir.exists() || !savesDir.isDirectory())
            {
                LOGGER.info("Trying to make directory "
                    + Constants.SAVE_DIR_NAME);
                if (!savesDir.mkdirs())
                {
                    LOGGER.log(Level.SEVERE,
                        "Could not create saves directory");
                    JOptionPane
                        .showMessageDialog(
                            null,
                            "Could not create directory "
                                + savesDir
                                + "\n- saving game failed! Unless the directory "
                                + "can be created, you can't use File=>Save, and "
                                + "make sure Autosave (in Game Setup) is disabled.",
                            "Can't save game!", JOptionPane.ERROR_MESSAGE);

                    return;
                }
            }

            fn = makeAutosaveFileName();
            if (autoSave)
            {
                // Real autosave
                LOGGER.finest("Autosaving game to " + fn);
                if (keep > 0)
                {
                    autoGeneratedFiles.add(fn);
                }
            }
            else
            {
                // File-Save (without providing a name) from File menu
                LOGGER.finest("File-Save saving the game to " + fn);
            }
        }
        else
        {
            fn = filename;
            LOGGER.info("Saving game to user-provided file name " + filename);
        }

        FileWriter fileWriter;
        try
        {
            fileWriter = new FileWriter(fn);
        }
        catch (IOException e)
        {
            LOGGER.log(Level.SEVERE, "Couldn't open " + fn, e);
            return;
        }
        PrintWriter out = new PrintWriter(fileWriter);

        try
        {
            Element root = new Element("ColossusSnapshot");

            root.setAttribute("version", Constants.XML_SNAPSHOT_VERSION);

            Document doc = new Document(root);

            Element el = new Element("Variant");

            el.setAttribute("dir", VariantSupport.getVarDirectory());
            el.setAttribute("file", VariantSupport.getVarFilename());
            el.setAttribute("name", VariantSupport.getVariantName());
            root.addContent(el);

            el = new Element("TurnNumber");
            el.addContent("" + getTurnNumber());
            root.addContent(el);

            el = new Element("CurrentPlayer");
            el.addContent("" + activePlayerNum);
            root.addContent(el);

            el = new Element("CurrentPhase");
            el.addContent("" + getPhase().toInt());
            root.addContent(el);

            Element car = new Element("Caretaker");

            root.addContent(car);

            // Caretaker stacks
            for (CreatureType creature : getVariant().getCreatureTypes())
            {
                el = new Element("Creature");
                el.setAttribute("name", creature.getName());
                el.setAttribute("remaining", ""
                    + getCaretaker().getAvailableCount(creature));
                el.setAttribute("dead", ""
                    + getCaretaker().getDeadCount(creature));
                car.addContent(el);
            }

            // Players
            for (Player p : getPlayers())
            {
                PlayerServerSide player = (PlayerServerSide)p;
                el = new Element("Player");
                el.setAttribute("name", player.getName());
                el.setAttribute("type", player.getType());
                el.setAttribute("color", player.getColor().getName());
                el.setAttribute("startingTower", player.getStartingTower()
                    .getLabel());
                el.setAttribute("score", "" + player.getScore());
                el.setAttribute("dead", "" + player.isDead());
                el.setAttribute("mulligansLeft", ""
                    + player.getMulligansLeft());
                el.setAttribute("colorsElim", player.getPlayersElim());
                el.setAttribute("movementRoll", "" + player.getMovementRoll());
                el.setAttribute("teleported", "" + player.hasTeleported());
                el.setAttribute("summoned", "" + player.hasSummoned());

                Collection<LegionServerSide> legions = player.getLegions();
                Iterator<LegionServerSide> it2 = legions.iterator();

                while (it2.hasNext())
                {
                    LegionServerSide legion = it2.next();

                    el.addContent(dumpLegion(legion, battleInProgress
                        && (legion == battle.getAttacker() || legion == battle
                            .getDefender())));
                }
                root.addContent(el);
            }

            // Dump the file cache, so that generated files are preserved
            Iterator<Element> itEl = StaticResourceLoader.getFileCacheDump()
                .iterator();
            while (itEl.hasNext())
            {
                root.addContent(itEl.next());
            }

            // Battle stuff
            if (engagementInProgress && battle != null)
            {
                Element bat = new Element("Battle");

                bat.setAttribute("masterHexLabel", battle.getMasterHex()
                    .getLabel());
                bat.setAttribute("turnNumber", "" + battle.getTurnNumber());
                bat.setAttribute("activePlayer", ""
                    + battle.getActivePlayer().getName());
                bat.setAttribute("phase", ""
                    + battle.getBattlePhase().ordinal());
                bat.setAttribute("summonState", "" + battle.getSummonState());
                bat.setAttribute("carryDamage", "" + battle.getCarryDamage());
                bat.setAttribute("driftDamageApplied", ""
                    + battle.isDriftDamageApplied());

                for (BattleHex hex : battle.getCarryTargets())
                {
                    Element ct = new Element("CarryTarget");
                    ct.addContent(hex.getLabel());
                    bat.addContent(ct);
                }
                root.addContent(bat);
            }
            root.addContent(history.getCopy());
            XMLOutputter putter = new XMLOutputter("    ", true);
            putter.output(doc, out);
            fileWriter.close();
            if ((filename == null || filename.equals("null")) && keep > 0)
            {
                while (autoGeneratedFiles.size() > keep)
                {
                    String delfilename = autoGeneratedFiles.remove(0);
                    File fileToDelete = new File(delfilename);
                    boolean success = fileToDelete.delete();
                    if (!success)
                    {
                        LOGGER.warning("Failed to delete autosave file "
                            + delfilename + "!");
                    }
                }
            }
        }
        catch (IOException ex)
        {
            LOGGER.log(Level.SEVERE, "Error writing XML savegame.", ex);
        }
    }

    private String notnull(String in)
    {
        if (in == null)
        {
            return "null";
        }
        return in;
    }

    private Element dumpLegion(LegionServerSide legion, boolean inBattle)
    {
        Element leg = new Element("Legion");

        leg.setAttribute("name", legion.getMarkerId());
        leg.setAttribute("currentHex", legion.getCurrentHex().getLabel());
        leg.setAttribute("startingHex", legion.getStartingHex().getLabel());
        leg.setAttribute("moved", "" + legion.hasMoved());
        EntrySide entrySide = legion.getEntrySide();
        if (entrySide == null)
        {
            // This should never happen. Let's follow it for a while
            // TODO This try-catch checking code can probably be removed
            // at some point.
            LOGGER.warning("EntrySide of Legion " + legion.getMarkerId()
                + " is null!?!");
            entrySide = EntrySide.NOT_SET;
        }
        leg.setAttribute("entrySide", "" + entrySide.ordinal());
        leg.setAttribute("parent", legion.getParent() != null ? notnull(legion
            .getParent().getMarkerId()) : "null");
        leg.setAttribute("recruitName", notnull(legion.getRecruitName()));
        leg.setAttribute("battleTally", "" + legion.getBattleTally());

        Collection<CreatureServerSide> critters = legion.getCreatures();
        Iterator<CreatureServerSide> it = critters.iterator();

        while (it.hasNext())
        {
            Creature critter = it.next();
            Element cre = new Element("Creature");

            cre.setAttribute("name", critter.getName());
            if (inBattle)
            {
                cre.setAttribute("hits", "" + critter.getHits());
                cre.setAttribute("currentHex", critter.getCurrentHex()
                    .getLabel());
                cre.setAttribute("startingHex", critter.getStartingHex()
                    .getLabel());
                cre.setAttribute("struck", "" + critter.hasStruck());
            }
            leg.addContent(cre);
        }
        return leg;
    }

    void autoSave()
    {
        if (getOption(Options.autosave) && !isGameOver())
        {
            saveGameInTry(null, true);
        }
    }

    /**
     * Try to load a game from saveDirName/filename.
     *
     * If the filename is "--latest" then load the latest savegame found in saveDirName.
     */
    // JDOM lacks generics, so we need casts
    @SuppressWarnings("unchecked")
    void loadGame(String filename)
    {
        File file = null;

        if (filename.equals("--latest"))
        {
            File dir = new File(Constants.SAVE_DIR_NAME);

            if (!dir.exists() || !dir.isDirectory())
            {
                LOGGER.log(Level.SEVERE, "No saves directory");
                dispose();
                return;
            }
            String[] filenames = dir.list(new XMLSnapshotFilter());

            if (filenames.length < 1)
            {
                LOGGER.log(Level.SEVERE,
                    "No XML savegames found in saves directory");
                dispose();
                return;
            }
            file = new File(Constants.SAVE_DIR_NAME
                + latestSaveFilename(filenames));
        }
        else if (filename.indexOf("/") >= 0 || filename.indexOf("\\") >= 0)
        {
            // Already a full path
            file = new File(filename);
        }
        else
        {
            file = new File(Constants.SAVE_DIR_NAME + filename);
        }

        if (!file.exists())
        {
            String tryXMLFile = file.getPath() + ".xml";
            File xmlFile = new File(tryXMLFile);
            if (xmlFile.exists())
            {
                LOGGER.warning("Given filename does not exist - loading "
                    + "instead the one with .xml appended to the name!");
                file = xmlFile;
            }
            else
            {
                LOGGER.severe("Cannot load saved game: file " + file.getPath()
                    + " does not exist!");
                return;
            }
        }

        try
        {
            LOGGER.info("Loading game from " + file);
            SAXBuilder builder = new SAXBuilder();
            Document doc = builder.build(file);

            Element root = doc.getRootElement();
            Attribute ver = root.getAttribute("version");

            if (!ver.getValue().equals(Constants.XML_SNAPSHOT_VERSION))
            {
                LOGGER.severe("Can't load this savegame version.");
                dispose();
                return;
            }

            // Reset flags that are not in the savegame file.
            clearFlags();
            loadingGame = true;

            Element el = root.getChild("Variant");
            Attribute dir = el.getAttribute("dir");
            Attribute fil = el.getAttribute("file");

            Attribute namAttr = el.getAttribute("name");
            String varName = null;
            if (namAttr != null)
            {
                varName = namAttr.getValue();
            }

            VariantSupport.freshenVariant(fil.getValue(), dir.getValue());

            // then load data files
            List<Element> datafilesElements = root.getChildren("DataFile");
            Iterator<Element> it = datafilesElements.iterator();
            while (it.hasNext())
            {
                Element dea = it.next();
                String mapKey = dea.getAttributeValue("DataFileKey");
                List<?> contentList = dea.getContent();
                if (contentList.size() > 0)
                {
                    String content = ((CDATA)contentList.get(0)).getText();
                    LOGGER.finest("DataFileKey: " + mapKey
                        + " DataFileContent :\n" + content);
                    StaticResourceLoader
                        .putIntoFileCache(mapKey, content.getBytes());
                }
                else
                {
                    StaticResourceLoader.putIntoFileCache(mapKey, new byte[0]);
                }
            }

            // we're server, but the file generation process has been done
            // by loading the savefile.
            VariantSupport.loadVariant(varName, fil.getValue(),
                dir.getValue(), false);
            // old save games (before r3360, 09/2008) do not save the
            // variant name - retrieve it back from VariantSupport.
            // TODO remove this one day?
            if (varName == null)
            {
                varName = VariantSupport.getVariantName();
            }
            options.setOption(Options.variant, varName);

            el = root.getChild("TurnNumber");
            turnNumber = Integer.parseInt(el.getTextTrim());
            // not quite the same as it was when saved, but the idea of lastRTN
            // is only to prevent stresstest games from hanging forever...
            lastRecruitTurnNumber = turnNumber;

            el = root.getChild("CurrentPlayer");
            activePlayerNum = Integer.parseInt(el.getTextTrim());

            el = root.getChild("CurrentPhase");
            phase = Phase.fromInt(Integer.parseInt(el.getTextTrim()));

            Element ct = root.getChild("Caretaker");
            List<Element> kids = ct.getChildren();
            it = kids.iterator();

            while (it.hasNext())
            {
                el = it.next();
                String creatureName = el.getAttribute("name").getValue();
                int remaining = el.getAttribute("remaining").getIntValue();
                int dead = el.getAttribute("dead").getIntValue();
                CreatureType creature = getVariant().getCreatureByName(
                    creatureName);

                getCaretaker().setAvailableCount(creature, remaining);
                getCaretaker().setDeadCount(creature, dead);
            }

            players.clear();
            if (battle != null)
            {
                server.allCleanupBattle();
            }

            // Players
            List<Element> playerElements = root.getChildren("Player");

            it = playerElements.iterator();
            while (it.hasNext())
            {
                Element pla = it.next();

                String name = pla.getAttribute("name").getValue();
                String type = pla.getAttribute("type").getValue();

                PlayerServerSide player = addPlayer(name, type);

                String colorName = pla.getAttribute("color").getValue();
                player.setColor(PlayerColor.getByName(colorName));

                String towerLabel = pla.getAttribute("startingTower")
                    .getValue();
                player.setStartingTower(getVariant().getMasterBoard()
                    .getHexByLabel(towerLabel));

                int score = pla.getAttribute("score").getIntValue();
                player.setScore(score);

                // Don't use the normal "dead" attribute - will be set
                // during replay...
                boolean dead = pla.getAttribute("dead").getBooleanValue();
                player.setDeadBeforeSave(dead);

                int mulligansLeft = pla.getAttribute("mulligansLeft")
                    .getIntValue();
                player.setMulligansLeft(mulligansLeft);

                player.setMovementRoll(pla.getAttribute("movementRoll")
                    .getIntValue());

                player.setTeleported(pla.getAttribute("teleported")
                    .getBooleanValue());

                // TODO what about the donor value? Just summoned is
                // good enough, so that at least one cannot summon
                // twice in same engagements-phase,
                // but not good enough to save a game in mid-battle
                // in particular in battle turn 4.
                player.setSummoned(pla.getAttribute("summoned")
                    .getBooleanValue());

                String playersElim = pla.getAttribute("colorsElim").getValue();
                if ("null".contains(playersElim))
                {
                    playersElim = "";
                }
                player.setPlayersElim(playersElim);

                List<Element> legionElements = pla.getChildren("Legion");
                Iterator<Element> it2 = legionElements.iterator();
                while (it2.hasNext())
                {
                    Element leg = it2.next();
                    readLegion(leg, player);
                }
            }

            // Battle stuff
            // TODO if the loading of a battle would be moved into the BattleServerSide class, then
            // the AngelSummoningStates and LegionTags enums could be private (possibly with some holes
            // for testing)
            Element bat = root.getChild("Battle");
            if (bat != null)
            {
                String engagementHexLabel = bat.getAttribute("masterHexLabel")
                    .getValue();
                MasterHex engagementHex = getVariant().getMasterBoard()
                    .getHexByLabel(engagementHexLabel);
                int battleTurnNum = bat.getAttribute("turnNumber")
                    .getIntValue();
                String battleActivePlayerName = bat.getAttribute(
                    "activePlayer").getValue();
                BattlePhase battlePhase = BattlePhase.values()[bat
                    .getAttribute("phase").getIntValue()];
                AngelSummoningStates summonState = AngelSummoningStates
                    .valueOf(bat.getAttribute("summonState").getValue());
                int carryDamage = bat.getAttribute("carryDamage")
                    .getIntValue();
                boolean driftDamageApplied = bat.getAttribute(
                    "driftDamageApplied").getBooleanValue();

                List<Element> cts = bat.getChildren("CarryTarget");
                Set<BattleHex> carryTargets = new HashSet<BattleHex>();
                Iterator<Element> it2 = cts.iterator();
                while (it2.hasNext())
                {
                    Element cart = it2.next();
                    carryTargets.add(HexMap.getHexByLabel(engagementHex
                        .getTerrain(), cart.getTextTrim()));
                }

                Player attackingPlayer = getActivePlayer();
                Legion attacker = getFirstFriendlyLegion(engagementHex,
                    attackingPlayer);
                Legion defender = getFirstEnemyLegion(engagementHex,
                    attackingPlayer);

                BattleServerSide.LegionTags activeLegionTag;
                if (battleActivePlayerName.equals(attackingPlayer.getName()))
                {
                    activeLegionTag = BattleServerSide.LegionTags.ATTACKER;
                }
                else
                {
                    activeLegionTag = BattleServerSide.LegionTags.DEFENDER;
                }

                battle = new BattleServerSide(this, attacker, defender,
                    activeLegionTag, engagementHex, battleTurnNum, battlePhase);
                battle.setSummonState(summonState);
                battle.setCarryDamage(carryDamage);
                battle.setDriftDamageApplied(driftDamageApplied);
                battle.setCarryTargets(carryTargets);
            }

            // Backup Legion data and wipe it out, so that history
            // starts from a clean table. After history reply, we compare
            // whether the replay result matches this "loaded data".
            for (Player buPlayer : getPlayers())
            {
                ((PlayerServerSide)buPlayer).backupLoadedData();
            }

            // History
            history = new History();
            Element his = root.getChild("History");
            history.copyTree(his);

            initServer();
            // Remaining stuff has been moved to loadGame2()

            // Some more stuff is done from loadGame2() when the last
            // expected client has connected.
            // Main thread has now nothing to do any more, can wait
            // until game finishes.
            cleanupWhenGameOver();
        }
        catch (RuntimeException rte)
        {
            LOGGER.log(Level.SEVERE, "RuntimeException!! "
                + "While trying to load (corrupt?) savegame", rte);
            dispose();
            return;
        }
        catch (Exception ex)
        {
            LOGGER.log(Level.SEVERE, "Tried to load corrupt savegame", ex);
            dispose();
            return;
        }
    }

    // JDOM lacks generics, so we need casts
    @SuppressWarnings("unchecked")
    private void readLegion(Element leg, PlayerServerSide player)
        throws DataConversionException
    {
        String markerId = leg.getAttribute("name").getValue();
        String currentHexLabel = leg.getAttribute("currentHex").getValue();
        MasterHex currentHex = getVariant().getMasterBoard().getHexByLabel(
            currentHexLabel);
        String startingHexLabel = leg.getAttribute("startingHex").getValue();
        MasterHex startingHex = getVariant().getMasterBoard().getHexByLabel(
            startingHexLabel);
        boolean moved = leg.getAttribute("moved").getBooleanValue();
        EntrySide entrySide = EntrySide.fromIntegerId(leg.getAttribute(
            "entrySide").getIntValue());
        String parentId = leg.getAttribute("parent").getValue();
        if (parentId.equals("null"))
        {
            parentId = null;
        }
        String recruitName = leg.getAttribute("recruitName").getValue();
        if (recruitName.equals("null"))
        {
            recruitName = null;
        }

        int battleTally = leg.getAttribute("battleTally").getIntValue();

        // Critters
        // find legion for them, if it doesn't exist create one
        LegionServerSide legion = (LegionServerSide)player
            .getLegionByMarkerId(markerId);
        if (legion == null)
        {
            // TODO can there ever be a legion before? If not: collect all data
            // first (including critters) and then create the legion in one go
            Legion parentLegion = player.getLegionByMarkerId(parentId);
            legion = new LegionServerSide(markerId, parentLegion, currentHex,
                startingHex, player, this);
            player.addLegion(legion);
        }
        else
        {
            LOGGER.warning("Legion for marker does already exist?");
        }

        List<Element> creatureElements = leg.getChildren("Creature");
        for (Element cre : creatureElements)
        {
            String name = cre.getAttribute("name").getValue();
            Creature critter = new CreatureServerSide(getVariant()
                .getCreatureByName(name), null, this);

            // Battle stuff
            if (cre.getAttribute("hits") != null)
            {
                int hits = cre.getAttribute("hits").getIntValue();

                critter.setHits(hits);

                MasterBoardTerrain terrain = getVariant().getMasterBoard()
                    .getHexByLabel(currentHexLabel).getTerrain();
                String currentBattleHexLabel = cre.getAttribute("currentHex")
                    .getValue();
                BattleHex currentBattleHex = HexMap.getHexByLabel(terrain,
                    currentBattleHexLabel);
                critter.setCurrentHex(currentBattleHex);

                String startingBattleHexLabel = cre
                    .getAttribute("startingHex").getValue();
                BattleHex startingBattleHex = HexMap.getHexByLabel(terrain,
                    startingBattleHexLabel);
                critter.setStartingHex(startingBattleHex);

                boolean struck = cre.getAttribute("struck").getBooleanValue();

                critter.setStruck(struck);
            }

            legion.addCritter(critter);
        }

        legion.setMoved(moved);
        legion.setRecruitName(recruitName);
        legion.setEntrySide(entrySide);
        legion.addToBattleTally(battleTally);
    }

    /* Called from the last ClientHandler connecting
     *  ( = when expected nr. of clients has connected).
     */
    boolean loadGame2()
    {
        server.allSetColor();

        // We need to set the autoPlay option before loading the board,
        // so that we can avoid showing boards for AI players.
        syncAutoPlay();
        syncOptions();

        server.allUpdatePlayerInfo(true);
        replayOngoing = true;
        server.allTellReplay(true, turnNumber);
        server.allInitBoard();

        history.fireEventsFromXML(server);
        boolean ok = resyncBackupData();
        LOGGER.info("Loading and resync result: " + ok);

        if (!ok)
        {
            LOGGER.severe("Loading and resync failed - Aborting!!");
            return false;
        }

        for (Player player : getPlayers())
        {
            ((PlayerServerSide)player).computeMarkersAvailable();
        }

        server.allFullyUpdateLegionStatus();
        server.allUpdatePlayerInfo(false);
        server.allTellAllLegionLocations();
        server.allTellReplay(false, 0);
        replayOngoing = false;

        if (battle != null)
        {
            battle.setServer(getServer());
            battle.init();
        }

        server.allS