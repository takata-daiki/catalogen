{
  "matchterm": "Chunks",
  "previouspage": null,
  "searchterm": "Chunks",
  "query": "Chunks",
  "language_filters": [
    {
      "count": 8487,
      "id": 23,
      "language": "Java"
    }
  ],
  "total": 8485,
  "results": [
    {
      "repo": "https://github.com/ekem/Terasology.git",
      "language": "Java",
      "linescount": 90,
      "location": "/src/main/java/org/terasology/world/chunks",
      "name": "Terasology",
      "url": "https://searchcode.com/codesearch/view/71923466/",
      "md5hash": "dbf506ea934385f97b9e0be75d2a3180",
      "lines": {
        "1": "package org.terasology.world.chunks;",
        "2": "",
        "6": "import org.terasology.game.CoreRegistry;",
        "7": "import org.terasology.protobuf.ChunksProtobuf;",
        "8": "import org.terasology.world.chunks.blockdata.TeraArrays;",
        "9": "",
        "13": "/**",
        "14": " * Chunks is the central registration point for chunk data. ",
        "15": " * <p/>",
        "16": " * Serialization and deserialization of Chunks into/from protobuf messages is supported through the methods",
        "17": " * {@code Chunks.encode(Chunk)} and {@code Chunks.decode(ChunksProtobuf.Chunk)}.",
        "18": " * <p/>",
        "19": " * Mods can register chunk data extensions through the method {@code Chunks.register(String, TeraArrays.Entry)}.",
        "24": " */",
        "25": "public final class Chunks {",
        "26": ""
      },
      "id": 71923466,
      "filename": "Chunks.java"
    },
    {
      "repo": "https://github.com/Inkybro/Terasology.git",
      "language": "Java",
      "linescount": 100,
      "location": "/engine/src/main/java/org/terasology/world/chunks",
      "name": "Terasology",
      "url": "https://searchcode.com/codesearch/view/93304009/",
      "md5hash": "afa9f84528e3da6d678ae2df65e03eaf",
      "lines": {
        "32": " * {@code Chunks.encode(Chunk)} and {@code Chunks.decode(ChunksProtobuf.Chunk)}.",
        "33": " * <p/>",
        "34": " * Mods can register chunk data extensions through the method {@code Chunks.register(String, TeraArrays.Entry)}.",
        "16": "",
        "17": "package org.terasology.world.chunks;",
        "20": "import com.google.common.collect.Maps;",
        "21": "import org.terasology.protobuf.ChunksProtobuf;",
        "22": "import org.terasology.protobuf.EntityData;",
        "23": "import org.terasology.world.chunks.blockdata.TeraArrays;",
        "24": "import org.terasology.world.chunks.internal.ChunkImpl;",
        "25": "",
        "28": "/**",
        "29": " * Chunks is the central registration point for chunk data.",
        "30": " * <p/>",
        "31": " * Serialization and deserialization of Chunks into/from protobuf messages is supported through the methods"
      },
      "id": 93304009,
      "filename": "Chunks.java"
    },
    {
      "repo": "https://github.com/faquino/iText-4.2.0.git",
      "language": "Java",
      "linescount": 76,
      "location": "/www/examples/com/lowagie/examples/objects",
      "name": "iText-4.2.0",
      "url": "https://searchcode.com/codesearch/view/70290335/",
      "md5hash": "371c8318f4a498d1411b260b36dea99e",
      "lines": {
        "32": "",
        "1": "/*",
        "2": " * $Id: Chunks.java 3373 2008-05-12 16:21:24Z xlv $",
        "33": "public class Chunks {",
        "49": "\t\t\tPdfWriter.getInstance(document,",
        "50": "\t\t\t\t\tnew FileOutputStream(\"Chunks.pdf\"));"
      },
      "id": 70290335,
      "filename": "Chunks.java"
    },
    {
      "repo": "https://github.com/eob/Play20.git",
      "language": "Java",
      "linescount": 1188,
      "location": "/framework/src/play/src/main/java/play/mvc",
      "name": "Play20",
      "url": "https://searchcode.com/codesearch/view/74838899/",
      "md5hash": "ec15e45bf1ee5991042b2b16e154d71d",
      "lines": {
        "96": "    public static Status status(int status, InputStream content) {",
        "97": "        return status(status, content, defaultChunkSize);",
        "195": "     */",
        "196": "    public static Status ok(InputStream content, int chunkSize) {",
        "197": "        return new Status(play.core.j.JavaResults.Ok(), content, chunkSize);",
        "198": "    }",
        "203": "    public static Status ok(File content) {",
        "204": "        return ok(content, defaultChunkSize);",
        "210": "    public static Status ok(File content, int chunkSize) {",
        "209": "     */",
        "18": "    static Codec utf8 = Codec.javaSupported(\"utf-8\");",
        "19": "    static int defaultChunkSize = 1024 * 8;",
        "212": "    }",
        "189": "    public static Status ok(InputStream content) {",
        "190": "        return ok(content, defaultChunkSize);",
        "211": "        return new Status(play.core.j.JavaResults.Ok(), content, chunkSize);"
      },
      "id": 74838899,
      "filename": "Results.java"
    },
    {
      "repo": "https://github.com/patrickgh3/spade.git",
      "language": "Java",
      "linescount": 451,
      "location": "/src/spade",
      "name": "spade",
      "url": "https://searchcode.com/codesearch/view/73909581/",
      "md5hash": "430e2898986983aa94bb376fb8d93afc",
      "lines": {
        "356": "        // finish area",
        "357": "        for (int x=cstart[chunks-1]+csize[chunks-1]+1;x<src.getWidth();x++) {",
        "326": "        BufferedImage src = loadImage(\"level/level_\"+levelref+\".png\");",
        "327": "        // cycle through and see how many chunks we have",
        "328": "        int chunks = -1;",
        "329": "        for (int x=0;x<src.getWidth();x++) {",
        "330": "            if (src.getRGB(x,0)==Type.CHUNK_BOUNDARY.val) chunks++;",
        "331": "        }",
        "332": "        // now, cycle through and determine where chunks start and how long they are, for reference.",
        "333": "        int[] csize = new int[chunks];",
        "334": "        int[] cstart = new int[chunks];",
        "335": "        int size = 0;",
        "343": "                cindex++;",
        "344": "                if (cindex<chunks) cstart[cindex] = ++x;",
        "358": "            for (int y=0;y<code[0].length;y++) {",
        "348": "        // next, add all necesarry elements to code[].",
        "349": "        int[][] code = new int[src.getWidth()-chunks-1][src.getHeight()];"
      },
      "id": 73909581,
      "filename": "Art.java"
    },
    {
      "repo": "https://github.com/mozack/abra.git",
      "language": "Java",
      "linescount": 306,
      "location": "/src/main/java/abra",
      "name": "abra",
      "url": "https://searchcode.com/codesearch/view/74258994/",
      "md5hash": "8794944e4f069daa4c910c1fb8084707",
      "lines": {
        "59": "\t\treturn chunks;",
        "40": "\t\t// Map of bases to SAMRecords.  Used to dedup reads.",
        "41": "\t\tMap<String, SAMRecord> chunks = new HashMap<String, SAMRecord>();",
        "74": "\t\t\tchunks = clop(chunks);",
        "72": "\t\tfor (Feature region : regions) {",
        "50": "\t\t\t",
        "51": "\t\t\tList<SAMRecord> contigChunks = chunkRead(contig);",
        "52": "\t\t\tfor (SAMRecord chunk : contigChunks) {",
        "53": "\t\t\t\tchunks.put(chunk.getReadString(), chunk);",
        "54": "\t\t\t}",
        "73": "\t\t\tMap<String, SAMRecord> chunks = chop(reader, region);",
        "24": " * Breaks contigs down to sub-contigs of length 2*read_length.",
        "25": " * Filters chunks that do not vary from reference",
        "26": " * Drops chunks that are wholly contained within another chunk",
        "27": " * ",
        "58": "\t\t"
      },
      "id": 74258994,
      "filename": "ContigChopper.java"
    },
    {
      "repo": "https://github.com/ActonZhuang/xwiki-rendering.git",
      "language": "Java",
      "linescount": 102,
      "location": "/xwiki-rendering-wikimodel/src/main/java/org/xwiki/rendering/wikimodel",
      "name": "xwiki-rendering",
      "url": "https://searchcode.com/codesearch/view/75937557/",
      "md5hash": "ddc5f7315fe79b81faffc5300b19233e",
      "lines": {
        "34": "    /**",
        "35": "     * Extracts the label from the array of chunks and returns it.",
        "36": "     *",
        "37": "     * @param chunks the array of chunks",
        "38": "     * @return a label extracted from the given array of chunks",
        "39": "     */",
        "40": "    protected String getLabel(String[] chunks)",
        "41": "    {",
        "42": "        return chunks.length > 1 ? chunks[1].trim() : null;",
        "45": "    /**",
        "46": "     * Extracts the link from the array of chunks and returns it.",
        "47": "     *",
        "48": "     * @param chunks the array of chunks",
        "49": "     * @return a link extracted from the given array of chunks",
        "50": "     */"
      },
      "id": 75937557,
      "filename": "WikiReferenceParser.java"
    },
    {
      "repo": "https://github.com/ekem/Terasology.git",
      "language": "Java",
      "linescount": 255,
      "location": "/src/main/java/org/terasology/world",
      "name": "Terasology",
      "url": "https://searchcode.com/codesearch/view/71922359/",
      "md5hash": "fdb84caaf6e5d540fca2cd70396eee9c",
      "lines": {
        "129": "        int chunkIndex = relChunkIndex(blockX, blockY, blockZ);",
        "130": "        return chunks[chunkIndex].getLight(TeraMath.calcBlockPos(blockX, blockY, blockZ, chunkFilterSize));",
        "35": "    private Region3i blockRegion;",
        "36": "    private Chunk[] chunks;",
        "38": "    private Vector3i chunkPower;",
        "39": "    private Vector3i chunkSize;",
        "142": "        int chunkIndex = relChunkIndex(blockX, blockY, blockZ);",
        "143": "        return chunks[chunkIndex].setBlock(TeraMath.calcBlockPos(blockX, blockY, blockZ, chunkFilterSize), type, oldType);",
        "25": "import org.terasology.world.chunks.ChunkProvider;",
        "23": "import org.terasology.world.block.management.BlockManager;",
        "24": "import org.terasology.world.chunks.Chunk;",
        "57": "    public static WorldView createWorldView(Region3i region, Vector3i offset, ChunkProvider chunkProvider) {",
        "26": "import org.terasology.world.liquid.LiquidData;",
        "155": "        int chunkIndex = relChunkIndex(x, y, z);",
        "156": "        return chunks[chunkIndex].getLiquid(TeraMath.calcBlockPos(x, y, z, chunkFilterSize));",
        "58": "        Chunk[] chunks = new Chunk[region.size().x * region.size().z];"
      },
      "id": 71922359,
      "filename": "WorldView.java"
    },
    {
      "repo": "https://github.com/creckx/dynmap.git",
      "language": "Java",
      "linescount": 1097,
      "location": "/src/main/java/org/dynmap/bukkit",
      "name": "dynmap",
      "url": "https://searchcode.com/codesearch/view/70892704/",
      "md5hash": "2da27846ec8a2e9dfa1eabe76811057c",
      "lines": {
        "36": "    private int nsect;",
        "37": "    private List<DynmapChunk> chunks;",
        "41": "    private boolean biome, biomeraw, highesty, blockdata;",
        "10": "import org.bukkit.block.Biome;",
        "11": "import org.bukkit.ChunkSnapshot;",
        "671": "    private static class SpoutChunkSnapshot implements ChunkSnapshot {",
        "157": "                        biome_css = snap;",
        "148": "            Object[] biomebase = null;",
        "149": "            ChunkSnapshot biome_css = null;",
        "670": "    ",
        "27": "/**",
        "28": " * Container for managing chunks - dependent upon using chunk snapshots, since rendering is off server thread",
        "42": "    private HiddenChunkStyle hidestyle = HiddenChunkStyle.FILL_AIR;",
        "158": "                        if (biome_css instanceof SpoutChunkSnapshot) {",
        "159": "                            biome_css = ((SpoutChunkSnapshot)biome_css).chunk;"
      },
      "id": 70892704,
      "filename": "NewMapChunkCache.java"
    },
    {
      "repo": "https://github.com/ekem/Terasology.git",
      "language": "Java",
      "linescount": 1145,
      "location": "/src/main/java/org/terasology/rendering/world",
      "name": "Terasology",
      "url": "https://searchcode.com/codesearch/view/71925582/",
      "md5hash": "69c2fb2893cb2161bdb25b72784367d3",
      "lines": {
        "64": "import org.terasology.world.chunks.ChunkStore;",
        "65": "import org.terasology.world.chunks.LocalChunkProvider;",
        "136": "",
        "137": "    /* CHUNKS */",
        "138": "    private ChunkTessellator chunkTessellator;",
        "139": "    private boolean pendingChunks = false;",
        "140": "    private final List<Chunk> chunksInProximity = Lists.newArrayList();",
        "141": "    private int chunkPosX, chunkPosZ;",
        "143": "    /* RENDERING */",
        "144": "    private final LinkedList<Chunk> renderQueueChunksOpaque = Lists.newLinkedList();",
        "145": "    private final LinkedList<Chunk> renderQueueChunksOpaqueShadow = Lists.newLinkedList();",
        "146": "    private final PriorityQueue<Chunk> renderQueueChunksSortedWater = new PriorityQueue<Chunk>(16 * 16, new ChunkProximityComparator());",
        "61": "import org.terasology.world.block.Block;",
        "62": "import org.terasology.world.chunks.Chunk;",
        "63": "import org.terasology.world.chunks.ChunkProvider;"
      },
      "id": 71925582,
      "filename": "WorldRenderer.java"
    },
    {
      "repo": "https://github.com/r0k3/gs-collections.git",
      "language": "Java",
      "linescount": 1837,
      "location": "/collections/src/main/java/com/gs/collections/impl/map/mutable",
      "name": "gs-collections",
      "url": "https://searchcode.com/codesearch/view/72627954/",
      "md5hash": "454f10da26ee975ae888c12e296d50f5",
      "lines": {
        "864": "            final AtomicReferenceArray<Object> currentArray = incoming.table;",
        "865": "            FutureTask<?>[] futures = new FutureTask<?>[chunks];",
        "866": "            int chunkSize = currentArray.length() / chunks;",
        "1096": "        final AtomicReferenceArray<Object> currentArray = this.table;",
        "1097": "        int chunks = blocks.size();",
        "1098": "        if (chunks > 1)",
        "1099": "        {",
        "1100": "            FutureTask<?>[] futures = new FutureTask<?>[chunks];",
        "1101": "            int chunkSize = currentArray.length() / chunks;",
        "846": "",
        "847": "    public void putAllInParallel(Map<K, V> map, int chunks, Executor executor)",
        "1102": "            if (currentArray.length() % chunks != 0)",
        "1103": "            {",
        "860": "        }",
        "861": "        if (map instanceof ConcurrentHashMap<?, ?> && chunks > 1 && map.size() > 50000)"
      },
      "id": 72627954,
      "filename": "ConcurrentHashMap.java"
    },
    {
      "repo": "https://github.com/riking/MinecraftForge.git",
      "language": "Java",
      "linescount": 1074,
      "location": "/src/main/java/net/minecraftforge/common",
      "name": "MinecraftForge",
      "url": "https://searchcode.com/codesearch/view/72856430/",
      "md5hash": "0b894e24d37faf2a5833b891843d9286",
      "lines": {
        "64": " * 5. When a world loads, saved tickets are offered to the mods associated with the tickets. The {@link Ticket#getModData()} that is set by the mod should be used to re-register",
        "65": " * chunks to stay loaded (and maybe take other actions).",
        "194": "        private LinkedHashSet<ChunkCoordIntPair> requestedChunks;",
        "167": "         *",
        "168": "         * WARNING: You cannot force chunks in this callback, it is strictly for allowing the mod",
        "193": "        private Type ticketType;",
        "75": "    private static int defaultMaxCount;",
        "76": "    private static int defaultMaxChunks;",
        "146": "         * based on the ticket count.",
        "147": "         * WARNING: You cannot force chunks in this callback, it is strictly for allowing the mod",
        "342": "        {",
        "343": "            return ImmutableSet.copyOf(requestedChunks);",
        "283": "         * provided to the {@link LoadingCallback} for the mod. It is recommended to use this to recover",
        "284": "         * useful state information for the forced chunks.",
        "61": " * 2. Mods ask for a ticket {@link #requestTicket(Object, World, Type)} and then hold on to that ticket.",
        "62": " * 3. Mods request chunks to stay loaded {@link #forceChunk(Ticket, ChunkCoordIntPair)} or remove chunks from force loading {@link #unforceChunk(Ticket, ChunkCoordIntPair)}."
      },
      "id": 72856430,
      "filename": "ForgeChunkManager.java"
    },
    {
      "repo": "https://github.com/netiskra/netty.git",
      "language": "Java",
      "linescount": 2069,
      "location": "/codec-http/src/main/java/io/netty/handler/codec/http/multipart",
      "name": "netty",
      "url": "https://searchcode.com/codesearch/view/73849767/",
      "md5hash": "2985b716f07c46abca549ee328c08f4b",
      "lines": {
        "1671": "     * @throws NotEnoughDataDecoderException",
        "1672": "     *             Need more chunks",
        "297": "     *",
        "298": "     * If chunked, all chunks must have been offered using offer() method. If",
        "302": "     * @throws NotEnoughDataDecoderException",
        "303": "     *             need more chunks",
        "1181": "     * @throws NotEnoughDataDecoderException",
        "1566": "     * @throws NotEnoughDataDecoderException",
        "284": "     * @throws NotEnoughDataDecoderException",
        "279": "     *",
        "280": "     * If chunked, all chunks must have been offered using offer() method. If",
        "315": "     *",
        "316": "     * If chunked, all chunks must have been offered using offer() method. If",
        "285": "     *             Need more chunks",
        "1182": "     *             Need more chunks and reset the readerInder to the previous",
        "1567": "     *             Need more chunks but do not reset the readerInder since some"
      },
      "id": 73849767,
      "filename": "HttpPostRequestDecoder.java"
    },
    {
      "repo": "https://github.com/beauli/databus.git",
      "language": "Java",
      "linescount": 506,
      "location": "/databus2-relay/databus2-relay-impl/src/test/java/com/linkedin/databus/core",
      "name": "databus",
      "url": "https://searchcode.com/codesearch/view/71547376/",
      "md5hash": "1ea696567e2f33d551607f86e26d9060",
      "lines": {
        "289": "",
        "290": "    ArrayList<byte[]> chunks = new ArrayList<byte[]>();",
        "163": "",
        "132": "",
        "133": "    ArrayList<byte[]> chunks = new ArrayList<byte[]>();",
        "294": "    HashMap<String, String> footers = new HashMap<String, String>();",
        "135": "    HashMap<String, String> footers = new HashMap<String, String>();",
        "168": "    HashMap<String, String> footers = new HashMap<String, String>();",
        "201": "    ArrayList<byte[]> chunks = new ArrayList<byte[]>();",
        "202": "    chunks.add(chunk1.getBytes());",
        "295": "    setupServer(HttpResponseStatus.BAD_GATEWAY, chunks, headers, footers);",
        "136": "    setupServer(HttpResponseStatus.OK,chunks, headers, footers);",
        "169": "    setupServer(HttpResponseStatus.OK,chunks, headers, footers);",
        "164": "    ArrayList<byte[]> chunks = new ArrayList<byte[]>();",
        "200": "    String chunk1 = \"hello\";",
        "318": "",
        "319": "  private void setupServerThread(HttpResponseStatus responseCode, List<byte[]> responseChunks,"
      },
      "id": 71547376,
      "filename": "TestChunkedBodyWritableByteChannel.java"
    },
    {
      "repo": "https://github.com/rpmadden08/block-game.git",
      "language": "Java",
      "linescount": 1158,
      "location": "/Client/src/com/companyname/blockgame",
      "name": "block-game",
      "url": "https://searchcode.com/codesearch/view/71787646/",
      "md5hash": "351eccec791c0a4824c63a4dca3356d6",
      "lines": {
        "769": "\t\t\t\t",
        "770": "\t\t\t\tf = new File(\"chunks/\"+(chunkOffsetX+2)+\"-\"+chunkOffsetY+\".sav\");",
        "681": "\t\t\t\t",
        "682": "\t\t\t\tf = new File(\"chunks/\"+chunkOffsetX+\"-\"+(chunkOffsetY +1)+\".sav\");",
        "11": "\tpublic static int worldW = CHUNCK_SIZE * NUMBER_OF_CHUNKS_ON_ONE_SIDE, worldH = CHUNCK_SIZE * NUMBER_OF_CHUNKS_ON_ONE_SIDE;",
        "669": "\t\t\t\tf = new File(\"chunks/\"+chunkOffsetX+\"-\"+chunkOffsetY +\".sav\");",
        "16": "//\tpublic int tileNXY[][] = new int [worldW][worldH];",
        "17": "\tpublic Chunk[][] chunk = new Chunk [NUMBER_OF_CHUNKS_ON_ONE_SIDE][NUMBER_OF_CHUNKS_ON_ONE_SIDE];",
        "18": "\tpublic Block[][] block = new Block [CHUNCK_SIZE * NUMBER_OF_CHUNKS_ON_ONE_SIDE][CHUNCK_SIZE * NUMBER_OF_CHUNKS_ON_ONE_SIDE];",
        "19": "\tpublic Block[][] block2 = new Block [worldW][worldH];",
        "821": "\t\t\t",
        "822": "\t\t\tFile f = new File(\"chunks/\"+(chunkOffsetX+2)+\"-\"+chunkOffsetY+\".sav\");",
        "919": "\t\t\t",
        "920": "\t\t\tFile f = new File(\"chunks/\"+(chunkOffsetX)+\"-\"+(chunkOffsetY+2)+\".sav\");",
        "668": "\t\t\t\t",
        "10": "public class Level {"
      },
      "id": 71787646,
      "filename": "Level.java"
    },
    {
      "repo": "https://github.com/x4n4th/CraftBukkit.git",
      "language": "Java",
      "linescount": 369,
      "location": "/src/main/java/net/minecraft/server",
      "name": "CraftBukkit",
      "url": "https://searchcode.com/codesearch/view/73085627/",
      "md5hash": "99495098d9744a30d531ac1027c20d6a",
      "lines": {
        "135": "",
        "136": "            this.chunks.put(LongHash.toLong(i, j), chunk); // CraftBukkit",
        "41": "    public boolean isChunkLoaded(int i, int j) {",
        "42": "        return this.chunks.containsKey(LongHash.toLong(i, j)); // CraftBukkit",
        "173": "            // CraftBukkit start",
        "174": "            Chunk chunk = (Chunk) this.chunks.get(LongHash.toLong(i, j));",
        "144": "                /*",
        "145": "                 * If it's a new world, the first few chunks are generated inside",
        "286": "        // CraftBukkit start",
        "55": "",
        "56": "                Chunk c = this.chunks.get(LongHash.toLong(i, j));",
        "283": "",
        "284": "    public boolean saveChunks(boolean flag, IProgressUpdate iprogressupdate) {",
        "29": "    public boolean forceChunkLoad = false; // true -> false",
        "30": "    public LongObjectHashMap<Chunk> chunks = new LongObjectHashMap<Chunk>();",
        "287": "        Iterator iterator = this.chunks.values().iterator();"
      },
      "id": 73085627,
      "filename": "ChunkProviderServer.java"
    },
    {
      "repo": "https://github.com/DarkSlim/MCPC-Plus.git",
      "language": "Java",
      "linescount": 4628,
      "location": "/src/minecraft/net/minecraft/world",
      "name": "MCPC-Plus",
      "url": "https://searchcode.com/codesearch/view/71229210/",
      "md5hash": "86570131cd9e4f3acfe240e4c7d521d3",
      "lines": {
        "2026": "            // CraftBukkit start - Fixed an NPE, don't process entities in chunks queued for unload",
        "2025": "",
        "650": "                    // CraftBukkit - check unload queue too so we don't leak a chunk",
        "651": "                    if (!this.chunkExists(k1, l1) || ((WorldServer) this).theChunkProviderServer.chunksToUnload.contains(k1, l1))",
        "207": "    /** Positions to update */",
        "208": "    //public Set activeChunkSet = new HashSet();",
        "209": "    protected gnu.trove.map.hash.TLongShortHashMap activeChunkSet; // Spigot",
        "210": "    public long ticksPerAnimalSpawns;",
        "307": "        this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit",
        "308": "        this.chunkTickRadius = (byte)((this.getServer().getViewDistance() < 7) ? this.getServer().getViewDistance() : 7); // CraftBukkit - don't tick chunks we don't load for player",
        "310": "        // Spigot start",
        "311": "        this.activeChunkSet = new gnu.trove.map.hash.TLongShortHashMap(getWorld().growthPerTick * 5, 0.7f, Long.MIN_VALUE, Short.MIN_VALUE);",
        "312": "        activeChunkSet.setAutoCompactionFactor(0.0F);",
        "313": "        // Spigot end",
        "636": "     */",
        "637": "    public boolean checkChunksExist(int par1, int par2, int par3, int par4, int par5, int par6)"
      },
      "id": 71229210,
      "filename": "World.java"
    },
    {
      "repo": "https://github.com/joe-io/vert.x.git",
      "language": "Java",
      "linescount": 1330,
      "location": "/vertx-core/src/test/java/vertx/tests/core/filesystem",
      "name": "vert.x",
      "url": "https://searchcode.com/codesearch/view/71496444/",
      "md5hash": "fa9e07b1a79c162531b582192fe35037",
      "lines": {
        "906": "    final String fileName = \"some-file.dat\";",
        "907": "    final int chunkSize = 1000;",
        "908": "    final int chunks = 10;",
        "909": "    byte[] content = TestUtils.generateRandomByteArray(chunkSize * chunks);",
        "910": "    final Buffer expected = new Buffer(content);",
        "921": "                if (arb.succeeded()) {",
        "851": "    final String fileName = \"some-file.dat\";",
        "852": "    final int chunkSize = 1000;",
        "853": "    final int chunks = 10;",
        "918": "          for (int i = 0; i < chunks; i++) {",
        "919": "            arr.result.read(buff, i * chunkSize, i * chunkSize, chunkSize, new AsyncResultHandler<Buffer>() {",
        "920": "              public void handle(final AsyncResult<Buffer> arb) {",
        "916": "        if (arr.succeeded()) {",
        "922": "                  if (++reads == chunks) {",
        "917": "          final Buffer buff = new Buffer(chunks * chunkSize);"
      },
      "id": 71496444,
      "filename": "TestClient.java"
    },
    {
      "repo": "https://github.com/ekem/Terasology.git",
      "language": "Java",
      "linescount": 582,
      "location": "/src/main/java/org/terasology/world/chunks",
      "name": "Terasology",
      "url": "https://searchcode.com/codesearch/view/71923413/",
      "md5hash": "9858a9f2e982d65c7269091af5587fab",
      "lines": {
        "32": "import org.terasology.world.block.management.BlockManager;",
        "33": "import org.terasology.world.chunks.blockdata.TeraArray;",
        "34": "import org.terasology.world.chunks.blockdata.TeraArrays;",
        "35": "import org.terasology.world.chunks.blockdata.TeraDenseArray4Bit;",
        "36": "import org.terasology.world.chunks.blockdata.TeraDenseArray8Bit;",
        "37": "import org.terasology.world.chunks.deflate.TeraDeflator;",
        "38": "import org.terasology.world.chunks.deflate.TeraStandardDeflator;",
        "39": "import org.terasology.world.liquid.LiquidData;",
        "15": " */",
        "16": "package org.terasology.world.chunks;",
        "50": "/**",
        "51": " * Chunks are the basic components of the world. Each chunk contains a fixed amount of blocks",
        "54": " * <p/>",
        "55": " * Chunks are tessellated on creation and saved to vertex arrays. From those VBOs are generated",
        "28": "import org.terasology.math.Vector3i;",
        "29": "import org.terasology.protobuf.ChunksProtobuf;"
      },
      "id": 71923413,
      "filename": "Chunk.java"
    },
    {
      "repo": "https://github.com/lairsdragon/craftbook.git",
      "language": "Java",
      "linescount": 279,
      "location": "/common/src/main/java/com/sk89q/craftbook/util",
      "name": "craftbook",
      "url": "https://searchcode.com/codesearch/view/73231138/",
      "md5hash": "62c57db8d7e802e3d5eefb83c3864ded",
      "lines": {
        "192": "     * @return chunks in the given radius",
        "193": "     */",
        "194": "    public static Set<Chunk> getSurroundingChunks(Block block, int radius) {",
        "197": "        radius = radius / 16 + 1;",
        "198": "        Set<Chunk> chunks = new LinkedHashSet<Chunk>();",
        "268": "        List<Player> players = new ArrayList<Player>();",
        "203": "            for (int z = radius; z >= 0; z--) {",
        "204": "                chunks.add(world.getChunkAt(cX + x, cZ + z));",
        "205": "                chunks.add(world.getChunkAt(cX - x, cZ - z));",
        "269": "        for (Chunk chunk : getSurroundingChunks(block, radius)) {",
        "186": "    /**",
        "187": "     * Gets all surrounding chunks near the given block and radius.",
        "188": "     *",
        "189": "     * @param block  to get surrounding chunks for",
        "191": "     *"
      },
      "id": 73231138,
      "filename": "LocationUtil.java"
    }
  ],
  "page": 0,
  "nextpage": 1,
  "source_filters": [
    {
      "count": 3993,
      "source": "Bitbucket",
      "id": 3
    },
    {
      "count": 3473,
      "source": "Github",
      "id": 2
    },
    {
      "count": 750,
      "source": "Google Code",
      "id": 1
    },
    {
      "count": 193,
      "source": "Sourceforge",
      "id": 4
    },
    {
      "count": 37,
      "source": "GitLab",
      "id": 13
    },
    {
      "count": 25,
      "source": "Unknown",
      "id": 0
    },
    {
      "count": 8,
      "source": "Gitorious",
      "id": 10
    },
    {
      "count": 5,
      "source": "CodePlex",
      "id": 5
    },
    {
      "count": 3,
      "source": "Google Android",
      "id": 12
    }
  ]
}